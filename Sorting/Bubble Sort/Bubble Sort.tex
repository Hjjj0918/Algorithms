\documentclass[UTF8]{ctexart}
\usepackage[margin=1in]{geometry}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{graphicx}
\usepackage{hyperref}

% 代码格式设置
\lstset{
    language=C++,
    basicstyle=\ttfamily\small,
    breaklines=true,
    numbers=left,
    numberstyle=\tiny,
    keywordstyle=\color{blue},
    commentstyle=\color{gray},
    stringstyle=\color{red},
    showstringspaces=false,
    backgroundcolor=\color{lightgray!20},
    frame=single
}

\title{\textbf{冒泡排序 (Bubble Sort)}}
\author{}
\date{}

\begin{document}

\maketitle

\section{概述}
冒泡排序（Bubble Sort）是一种简单的排序算法，它通过重复地遍历列表，比较相邻的两个元素，如果它们的顺序错误则交换它们，直到列表有序为止。该算法因为较小的元素逐渐"浮起"到列表前面而得名。

\section{算法原理}

\subsection{基本思想}
冒泡排序的核心思想是：
\begin{enumerate}
    \item 比较相邻的两个元素
    \item 如果第一个比第二个大，则交换它们
    \item 重复这个过程，直到没有更多的元素需要比较
    \item 下一次遍历时，最后一个已排序的元素不再参与比较
\end{enumerate}

\subsection{步骤说明}
设数组为 $A = \{a_1, a_2, \ldots, a_n\}$，冒泡排序的步骤如下：
\begin{itemize}
    \item 第1趟：从头开始，比较 $a_1$ 和 $a_2$，交换如果需要；然后比较 $a_2$ 和 $a_3$，依此类推，直到 $a_{n-1}$ 和 $a_n$。最大的元素将移动到位置 $n$。
    \item 第2趟：对前 $n-1$ 个元素重复上述过程，最大的元素将移动到位置 $n-1$。
    \item 继续进行 $n-1$ 趟，直到数组完全有序。
\end{itemize}

\section{C++ 实现}

\subsection{基础版本}
\begin{lstlisting}
#include <iostream>
#include <vector>
using namespace std;

// 冒泡排序的基础实现
// 时间复杂度: O(n^2)
// 空间复杂度: O(1)
void bubbleSort(vector<int>& arr) {
    int n = arr.size();
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n - i - 1; j++) {
            if (arr[j] > arr[j + 1]) {
                // 交换相邻元素
                swap(arr[j], arr[j + 1]);
            }
        }
    }
}

// 主程序示例
int main() {
    vector<int> arr = {5, 2, 8, 1, 9};
    bubbleSort(arr);
    
    for (int num : arr) {
        cout << num << " ";
    }
    cout << endl;
    return 0;
}
\end{lstlisting}

\subsection{优化版本}
\begin{lstlisting}
#include <iostream>
#include <vector>
using namespace std;

// 冒泡排序的优化版本
// 如果某趟遍历中没有发生交换，说明数组已经有序
void bubbleSortOptimized(vector<int>& arr) {
    int n = arr.size();
    for (int i = 0; i < n; i++) {
        bool swapped = false;
        for (int j = 0; j < n - i - 1; j++) {
            if (arr[j] > arr[j + 1]) {
                swap(arr[j], arr[j + 1]);
                swapped = true;
            }
        }
        // 如果没有发生交换，数组已有序，提前退出
        if (!swapped) {
            break;
        }
    }
}

// 模板版本（支持任何可比较的数据类型）
template <typename T>
void bubbleSortTemplate(vector<T>& arr) {
    int n = arr.size();
    for (int i = 0; i < n; i++) {
        bool swapped = false;
        for (int j = 0; j < n - i - 1; j++) {
            if (arr[j] > arr[j + 1]) {
                swap(arr[j], arr[j + 1]);
                swapped = true;
            }
        }
        if (!swapped) {
            break;
        }
    }
}
\end{lstlisting}

\section{复杂度分析}

\subsection{时间复杂度}
\begin{itemize}
    \item \textbf{最坏情况：} $O(n^2)$ \\
    当数组按降序排列时，需要进行最多的比较和交换操作。
    
    \item \textbf{平均情况：} $O(n^2)$ \\
    平均需要进行约 $\frac{n(n-1)}{4}$ 次比较。
    
    \item \textbf{最好情况：} $O(n)$（优化版本） \\
    当数组已经排好序时，优化版本只需一趟遍历，进行 $n-1$ 次比较。
\end{itemize}

\subsection{空间复杂度}
$O(1)$ 

冒泡排序是原地排序算法，只需要常数级别的额外空间用于存储临时变量。

\section{特点与应用}

\subsection{优点}
\begin{itemize}
    \item 实现简单，易于理解
    \item 不需要额外的内存空间（原地排序）
    \item 是稳定的排序算法（相等元素的相对顺序不变）
    \item 适合小规模数据的排序
\end{itemize}

\subsection{缺点}
\begin{itemize}
    \item 时间复杂度为 $O(n^2)$，不适合大规模数据
    \item 与其他高效的排序算法（如快速排序、归并排序）相比，性能较差
    \item 在实际应用中很少使用
\end{itemize}

\subsection{应用场景}
\begin{itemize}
    \item 教学目的：作为排序算法的入门级算法
    \item 小数据集：对于少于50个元素的数据效率尚可
    \item 几乎有序的数据：优化版本可以快速检测有序数据
\end{itemize}

\section{示例}

\subsection{执行过程}
设初始数组为 $[5, 2, 8, 1, 9]$

\begin{itemize}
    \item \textbf{第1趟：} $[2, 5, 1, 8, 9]$ （最大元素9已在正确位置）
    \item \textbf{第2趟：} $[2, 1, 5, 8, 9]$ （8已在正确位置）
    \item \textbf{第3趟：} $[1, 2, 5, 8, 9]$ （5已在正确位置）
    \item \textbf{第4趟：} $[1, 2, 5, 8, 9]$ （数组已有序）
\end{itemize}

\section{总结}
冒泡排序虽然是一种最简单的排序算法，但其 $O(n^2)$ 的时间复杂度限制了它的实用性。它主要用于教学目的，帮助初学者理解排序算法的基本概念。在实际应用中，应优先选择快速排序、归并排序或堆排序等更高效的算法。

\end{document}