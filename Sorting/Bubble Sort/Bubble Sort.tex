\documentclass[UTF8]{ctexart}
\usepackage[margin=1in]{geometry}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{graphicx}
\usepackage{hyperref}

% 代码格式设置
\lstset{
    language=C++,
    basicstyle=\ttfamily\small,
    breaklines=true,
    numbers=left,
    numberstyle=\tiny,
    keywordstyle=\color{blue},
    commentstyle=\color{gray},
    stringstyle=\color{red},
    showstringspaces=false,
    backgroundcolor=\color{lightgray!20},
    frame=single
}

\title{\textbf{冒泡排序 (Bubble Sort)}}
\author{}
\date{}

\begin{document}

\maketitle

\section{概述}
冒泡排序（Bubble Sort）是一种简单的排序算法，它通过重复地遍历列表，比较相邻的两个元素，如果它们的顺序错误则交换它们，直到列表有序为止。该算法因为较小的元素逐渐"浮起"到列表前面而得名。

\section{算法原理}

\subsection{基本思想}
冒泡排序的核心思想是：
\begin{enumerate}
    \item 比较相邻的两个元素
    \item 如果第一个比第二个大，则交换它们
    \item 重复这个过程，直到没有更多的元素需要比较
    \item 下一次遍历时，最后一个已排序的元素不再参与比较
\end{enumerate}

\subsection{步骤说明}
设数组为 $A = \{a_1, a_2, \ldots, a_n\}$，冒泡排序的步骤如下：
\begin{itemize}
    \item 第1趟：从头开始，比较 $a_1$ 和 $a_2$，交换如果需要；然后比较 $a_2$ 和 $a_3$，依此类推，直到 $a_{n-1}$ 和 $a_n$。最大的元素将移动到位置 $n$。
    \item 第2趟：对前 $n-1$ 个元素重复上述过程，最大的元素将移动到位置 $n-1$。
    \item 继续进行 $n-1$ 趟，直到数组完全有序。
\end{itemize}

\section{C++ 实现}

\subsection{基础版本}
\begin{lstlisting}
#include <iostream>
#include <vector>
using namespace std;

// 冒泡排序的基础实现
// 时间复杂度: O(n^2)
// 空间复杂度: O(1)
void bubbleSort(vector<int>& arr) {
    int n = arr.size();
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n - i - 1; j++) {
            if (arr[j] > arr[j + 1]) {
                // 交换相邻元素
                swap(arr[j], arr[j + 1]);
            }
        }
    }
}

// 主程序示例
int main() {
    vector<int> arr = {5, 2, 8, 1, 9};
    bubbleSort(arr);
    
    for (int num : arr) {
        cout << num << " ";
    }
    cout << endl;
    return 0;
}
\end{lstlisting}

\subsection{优化版本}
\begin{lstlisting}
#include <iostream>
#include <vector>
using namespace std;

// 冒泡排序的优化版本
// 如果某趟遍历中没有发生交换，说明数组已经有序
void bubbleSortOptimized(vector<int>& arr) {
    int n = arr.size();
    for (int i = 0; i < n; i++) {
        bool swapped = false;
        for (int j = 0; j < n - i - 1; j++) {
            if (arr[j] > arr[j + 1]) {
                swap(arr[j], arr[j + 1]);
                swapped = true;
            }
        }
        // 如果没有发生交换，数组已有序，提前退出
        if (!swapped) {
            break;
        }
    }
}

// 模板版本（支持任何可比较的数据类型）
template <typename T>
void bubbleSortTemplate(vector<T>& arr) {
    int n = arr.size();
    for (int i = 0; i < n; i++) {
        bool swapped = false;
        for (int j = 0; j < n - i - 1; j++) {
            if (arr[j] > arr[j + 1]) {
                swap(arr[j], arr[j + 1]);
                swapped = true;
            }
        }
        if (!swapped) {
            break;
        }
    }
}
\end{lstlisting}

\section{复杂度分析}

\subsection{时间复杂度}
\begin{itemize}
    \item \textbf{最坏情况：} $O(n^2)$ \\
    当数组按降序排列时，需要进行最多的比较和交换操作。
    
    \item \textbf{平均情况：} $O(n^2)$ \\
    平均需要进行约 $\frac{n(n-1)}{4}$ 次比较。
    
    \item \textbf{最好情况：} $O(n)$（优化版本） \\
    当数组已经排好序时，优化版本只需一趟遍历，进行 $n-1$ 次比较。
\end{itemize}

\subsection{空间复杂度}
$O(1)$ 

冒泡排序是原地排序算法，只需要常数级别的额外空间用于存储临时变量。
\subsection{平均情况分析（基于倒置）}

\paragraph{倒置（Inversion）的定义}
给定列表中的一个元素 $x$，若存在元素 $y$ 满足：
\begin{itemize}
    \item $y < x$，且
    \item $y$ 在 $x$ 的右侧，
\end{itemize}
则称 $y$ 是 $x$ 的一个\emph{倒置}（inversion）。

例如，对数组 $[2,\;4,\;3,\;1,\;5]$，元素 $4$ 的倒置为 $3$ 和 $1$。按元素计数，所有倒置的总数为 $1+2+1=4$。

\paragraph{与冒泡排序的关系 — 问题与观察}
\begin{itemize}
    \item Q: 排序好的数组中有多少个倒置？\\
    \item A: 0 个倒置。
    \item Q: 交换一对相邻元素可以消除多少个倒置？\\
    \item A: 每次交换相邻的一对元素最多消除 1 个倒置（若它们形成倒置）。
    \item Q: 冒泡排序需要多少次交换？\\
    \item A: 冒泡排序所做的交换总数等于输入中的倒置总数（每次相邻交换消除恰好 1 个倒置）。
    \item Q: 长度为 $n$ 的序列共有多少种可能的初始排列？\\
    \item A: $n!$ 种排列。
\end{itemize}

\paragraph{倒置论证（平均情况）}
设输入集合为所有长度为 $n$ 的排列，记为 $S$。我们要计算在随机排列下倒置的期望值。

对任意一对不同位置上的元素 $(i,j)$（其中 $i<j$ 表示位置），在所有排列中，恰有一半的排列会使这对元素形成倒置。更直接的证明方法是将排列与其逆序排列配对：对于任意排列 $I$，其逆序排列 $I^r$ 也属于 $S$，且对于任意一对值（不论大小），在 $I$ 与 $I^r$ 中恰好有一个排列将该对视为倒置。

因此，对于每一对不同元素，考虑它们在所有排列中形成倒置的总次数为 $\frac{n!}{2}$。令 $X$ 为一个排列中的倒置总数，则所有排列的倒置总和为
$$\sum_{I\in S} X(I)=\binom{n}{2}\cdot\frac{n!}{2}.$$ 
于是，平均每个排列的倒置数为
$$\mathbb{E}[X]=\frac{1}{n!}\sum_{I\in S} X(I)=\frac{\binom{n}{2}}{2}=\frac{n(n-1)}{4}.$$

由于冒泡排序的交换次数等于倒置数的个数，平均情况下冒泡排序需要执行约 $n(n-1)/4$ 次交换，并且相同阶的比较次数也为 $\Theta(n^2)$。因此，冒泡排序的平均时间复杂度为 $\Theta(n^2)$。

\section{特点与应用}

\subsection{优点}
\begin{itemize}
    \item 实现简单，易于理解
    \item 不需要额外的内存空间（原地排序）
    \item 是稳定的排序算法（相等元素的相对顺序不变）
    \item 适合小规模数据的排序
\end{itemize}

\subsection{缺点}
\begin{itemize}
    \item 时间复杂度为 $O(n^2)$，不适合大规模数据
    \item 与其他高效的排序算法（如快速排序、归并排序）相比，性能较差
    \item 在实际应用中很少使用
\end{itemize}

\subsection{应用场景}
\begin{itemize}
    \item 教学目的：作为排序算法的入门级算法
    \item 小数据集：对于少于50个元素的数据效率尚可
    \item 几乎有序的数据：优化版本可以快速检测有序数据
\end{itemize}

\section{示例}

\subsection{执行过程}
设初始数组为 $[5, 2, 8, 1, 9]$

\begin{itemize}
    \item \textbf{第1趟：} $[2, 5, 1, 8, 9]$ （最大元素9已在正确位置）
    \item \textbf{第2趟：} $[2, 1, 5, 8, 9]$ （8已在正确位置）
    \item \textbf{第3趟：} $[1, 2, 5, 8, 9]$ （5已在正确位置）
    \item \textbf{第4趟：} $[1, 2, 5, 8, 9]$ （数组已有序）
\end{itemize}

\section{总结}
冒泡排序虽然是一种最简单的排序算法，但其 $O(n^2)$ 的时间复杂度限制了它的实用性。它主要用于教学目的，帮助初学者理解排序算法的基本概念。在实际应用中，应优先选择快速排序、归并排序或堆排序等更高效的算法。

\end{document}