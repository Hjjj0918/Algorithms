\documentclass[UTF8]{ctexart}
\usepackage[margin=1in]{geometry}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{graphicx}
\usepackage{hyperref}

% 代码格式设置
\lstset{
    language=C++,
    basicstyle=\ttfamily\small,
    breaklines=true,
    numbers=left,
    numberstyle=\tiny,
    keywordstyle=\color{blue},
    commentstyle=\color{gray},
    stringstyle=\color{red},
    showstringspaces=false,
    backgroundcolor=\color{lightgray!20},
    frame=single
}

\title{\textbf{归并排序 (Merge Sort)}}
\author{}
\date{}

\begin{document}

\maketitle

\section{概述}
归并排序（Merge Sort）是一种高效的分治排序算法，它通过将列表分成两个大小相等的部分，分别对这两个部分进行排序，然后将排序好的两个部分合并成一个有序列表。该算法具有稳定、时间复杂度为 $O(n \log n)$ 等优点，特别适合于大规模数据的排序。

\section{算法原理}

\subsection{基本思想}
归并排序的核心思想是：
\begin{enumerate}
    \item 将列表分成两个大小大致相等的部分
    \item 对这两个部分分别进行递归排序
    \item 将两个已排序的部分合并成一个有序列表
\end{enumerate}

\subsection{步骤说明}
设数组为 $A = \{a_1, a_2, \ldots, a_n\}$，归并排序的步骤如下：
\begin{itemize}
    \item \textbf{分割阶段（Divide）}：递归地将数组分成两个子数组，直到每个子数组只包含一个元素。
    \item \textbf{合并阶段（Merge）}：将相邻的已排序子数组合并，逐步构建更大的有序数组，直到整个数组排序完成。
\end{itemize}

\section{算法示例}

\subsection{示例数组}
设数组为：$A = [24, 13, 1, 26, 28, 15, 27, 2]$

\subsection{分割与排序过程}
\begin{verbatim}
分割过程：
                [24 13 1 26 28 15 27 2]
               /                      \
         [24 13 1 26]            [28 15 27 2]
         /          \            /          \
     [24 13]      [1 26]      [28 15]     [27 2]
     /    \       /    \       /    \       /   \
   [24]  [13]   [1]  [26]   [28]  [15]   [27] [2]
\end{verbatim}

\subsection{合并与排序过程}
\begin{verbatim}
合并过程：
   [24]  [13]   [1]  [26]   [28]  [15]   [27] [2]
      |      |     |      |     |       |    |      |
     [13 24]    [1 26]      [15 28]     [2 27]
           |                 |           |
        [1 13 24 26]     [2 15 27 28]
                  |                |
           [1 2 13 15 24 26 27 28]
\end{verbatim}

\section{C++ 实现}

\subsection{基础版本}
\begin{lstlisting}
#include <iostream>
#include <vector>
using namespace std;

// 将两个已排序的子数组 A[low..mid] 和 A[mid+1..high] 合并
// 时间复杂度: O(n)，其中 n = high - low + 1
// 空间复杂度: O(n)（用于临时数组）
void merge(vector<int>& arr, int low, int mid, int high) {
    // 创建临时数组
    vector<int> left(arr.begin() + low, arr.begin() + mid + 1);
    vector<int> right(arr.begin() + mid + 1, arr.begin() + high + 1);
    
    int i = 0, j = 0, k = low;
    
    // 比较并合并两个子数组
    while (i < left.size() && j < right.size()) {
        if (left[i] <= right[j]) {
            arr[k++] = left[i++];
        } else {
            arr[k++] = right[j++];
        }
    }
    
    // 复制剩余的元素
    while (i < left.size()) {
        arr[k++] = left[i++];
    }
    while (j < right.size()) {
        arr[k++] = right[j++];
    }
}

// 归并排序的递归实现
// 排序子数组 A[low..high]
void mergeSort(vector<int>& arr, int low, int high) {
    if (low < high) {
        int mid = low + (high - low) / 2;
        
        // 递归排序左半部分
        mergeSort(arr, low, mid);
        
        // 递归排序右半部分
        mergeSort(arr, mid + 1, high);
        
        // 合并已排序的两部分
        merge(arr, low, mid, high);
    }
}

// 主程序示例
int main() {
    vector<int> arr = {24, 13, 1, 26, 28, 15, 27, 2};
    
    cout << "排序前：";
    for (int num : arr) {
        cout << num << " ";
    }
    cout << endl;
    
    mergeSort(arr, 0, arr.size() - 1);
    
    cout << "排序后：";
    for (int num : arr) {
        cout << num << " ";
    }
    cout << endl;
    
    return 0;
}
\end{lstlisting}

\subsection{迭代版本}
\begin{lstlisting}
#include <iostream>
#include <vector>
using namespace std;

void merge(vector<int>& arr, int low, int mid, int high) {
    vector<int> left(arr.begin() + low, arr.begin() + mid + 1);
    vector<int> right(arr.begin() + mid + 1, arr.begin() + high + 1);
    
    int i = 0, j = 0, k = low;
    
    while (i < left.size() && j < right.size()) {
        if (left[i] <= right[j]) {
            arr[k++] = left[i++];
        } else {
            arr[k++] = right[j++];
        }
    }
    
    while (i < left.size()) {
        arr[k++] = left[i++];
    }
    while (j < right.size()) {
        arr[k++] = right[j++];
    }
}

// 自底向上的迭代归并排序
void mergeSortIterative(vector<int>& arr) {
    int n = arr.size();
    
    // 从大小为 1 的子数组开始，逐步增大合并的子数组大小
    for (int currSize = 1; currSize < n; currSize *= 2) {
        // 选择起始点进行合并
        for (int leftStart = 0; leftStart < n; leftStart += currSize * 2) {
            int mid = min(leftStart + currSize - 1, n - 1);
            int rightEnd = min(leftStart + currSize * 2 - 1, n - 1);
            
            if (mid < rightEnd) {
                merge(arr, leftStart, mid, rightEnd);
            }
        }
    }
}

int main() {
    vector<int> arr = {24, 13, 1, 26, 28, 15, 27, 2};
    
    cout << "排序前：";
    for (int num : arr) {
        cout << num << " ";
    }
    cout << endl;
    
    mergeSortIterative(arr);
    
    cout << "排序后：";
    for (int num : arr) {
        cout << num << " ";
    }
    cout << endl;
    
    return 0;
}
\end{lstlisting}

\section{复杂度分析}

\subsection{Merge() 操作的复杂度}

\textbf{问题：Merge() 操作的时间复杂度是多少？}

\textbf{答案：} Merge 操作的时间复杂度为 $\mathbf{O(n)}$，其中 $n$ 是被合并的元素总数。

\textbf{分析：}
\begin{itemize}
    \item 创建两个临时数组：$O(n)$
    \item 比较并合并两个已排序的子数组：需要遍历每个元素恰好一次，共 $n$ 次操作
    \item 复制剩余元素：$O(n)$
    \item 总体：$O(n) + O(n) + O(n) = O(n)$
\end{itemize}

\textbf{空间复杂度：} $O(n)$（用于存储临时数组）

\subsection{MergeSort() 的整体复杂度}

\textbf{问题：MergeSort() 的时间复杂度是多少？}

\textbf{答案：} 归并排序的时间复杂度为 $\mathbf{O(n \log n)}$。

\textbf{分析：}
\begin{itemize}
    \item \textbf{递归树深度：} $\log_2 n$（每次将数组分成两半）
    \item \textbf{每层的工作量：} 在递归树的第 $k$ 层，有 $2^k$ 个大小为 $n/2^k$ 的子数组需要合并，合并工作量为 $O(n)$
    \item \textbf{总工作量：} $(\log_2 n) \times O(n) = O(n \log n)$
\end{itemize}

\subsection{时间复杂度总结}
\begin{itemize}
    \item \textbf{最坏情况：} $O(n \log n)$ \\
    任意初始排列都需要进行完整的分割和合并过程。
    
    \item \textbf{平均情况：} $O(n \log n)$ \\
    期望运行时间与最坏情况相同。
    
    \item \textbf{最好情况：} $O(n \log n)$ \\
    即使输入已经部分排序，也需要进行相同的分割和合并操作。
\end{itemize}

\subsection{空间复杂度}
$O(n)$

归并排序需要额外的 $O(n)$ 空间来存储临时数组，因此不是原地排序算法。

\section{特点与应用}

\subsection{优点}
\begin{itemize}
    \item 时间复杂度稳定，最坏、最好、平均情况均为 $O(n \log n)$
    \item 是稳定的排序算法（相等元素的相对顺序不变）
    \item 特别适合于链表的排序，可以实现 $O(1)$ 的额外空间
    \item 适合于外部排序（处理不能完全装入内存的大数据集）
    \item 可以并行化处理，提高大规模数据排序的性能
\end{itemize}

\subsection{缺点}
\begin{itemize}
    \item 需要 $O(n)$ 的额外空间，不是原地排序
    \item 对于小规模数据，性能不如快速排序和堆排序
    \item 当数据已经排序或接近排序时，无法利用这一特性进行优化
    \item 在实际应用中，额外的空间开销可能导致缓存效率不如原地排序算法高
\end{itemize}

\subsection{应用场景}
\begin{itemize}
    \item 处理大规模数据集，需要稳定的排序性能
    \item 链表排序（避免了数组的随机访问问题）
    \item 归并有序的数据流
    \item 外部排序和多路合并
    \item 需要稳定排序的场景（例如数据库查询结果）
\end{itemize}

\end{document}
